# Browser File System APIs:  Analysis & Wrapper Design

## Executive Summary

There are **four distinct browser APIs** for file system access, each with different capabilities, standardization status, and browser support.  For building a robust wrapper, the recommended approach is to **layer these APIs** with OPFS as the primary storage layer and File System Access API for user file interaction.

---

## API Landscape Overview

| API | Standardization | Read | Write | User Prompt | Origin-Private | Browser Support |
|-----|-----------------|------|-------|-------------|----------------|-----------------|
| **File API** | W3C Standard | ✅ | ❌ | Via `<input>` | N/A | Universal |
| **File and Directory Entries API** | Non-standard | ✅ | ❌ | Via drag-drop | N/A | Chromium, partial Firefox |
| **File System Access API** | WICG Draft | ✅ | ✅ | Native dialogs | ❌ | Chromium only |
| **Origin Private File System (OPFS)** | WHATWG Standard | ✅ | ✅ | None needed | ✅ | All modern browsers |

---

## 1. File API (Legacy, Read-Only)

### What It Is
The original W3C File API provides read-only access to files selected through `<input type="file">` or drag-and-drop. 

### Key Interfaces
```typescript
interface File extends Blob {
    readonly name: string
    readonly lastModified: number
    readonly webkitRelativePath: string
}

interface FileReader extends EventTarget {
    readAsArrayBuffer(blob: Blob): void
    readAsDataURL(blob:  Blob): void
    readAsText(blob: Blob, encoding?: string): void
    readonly result: string | ArrayBuffer | null
}
```

### Modern Usage (Promise-based)
```typescript
// File now has . text(), .arrayBuffer(), .stream() methods
const file:  File = inputElement.files[0]
const text = await file.text()
const buffer = await file.arrayBuffer()
const stream = file.stream()
```

### Limitations
- **Read-only**: Cannot write back to the file
- **No persistence**: File reference lost on page reload
- **No directory creation**: Can only read what user provides

### Wrapper Value
Minimal—modern `File` methods are already Promise-based.  Useful only for consistent API surface.

---

## 2. File and Directory Entries API (Legacy, Drag-Drop)

### What It Is
A non-standard API originally from Chrome's deprecated File System API, now used primarily for processing directories from drag-and-drop. 

### Key Interfaces
```typescript
interface FileSystemEntry {
    readonly isFile: boolean
    readonly isDirectory: boolean
    readonly name:  string
    readonly fullPath: string
    readonly filesystem: FileSystem
    getParent(successCallback: (entry: FileSystemDirectoryEntry) => void): void
}

interface FileSystemFileEntry extends FileSystemEntry {
    file(successCallback: (file: File) => void): void
}

interface FileSystemDirectoryEntry extends FileSystemEntry {
    createReader(): FileSystemDirectoryReader
}

interface FileSystemDirectoryReader {
    readEntries(successCallback: (entries: FileSystemEntry[]) => void): void
}
```

### Callback Hell Problem
```typescript
// Native API is callback-based and incomplete
function readDirectory(entry: FileSystemDirectoryEntry): void {
    const reader = entry.createReader()
    const entries: FileSystemEntry[] = []
    
    function readBatch(): void {
        reader.readEntries((batch) => {
            if (batch.length === 0) {
                // Done - process entries
                entries.forEach(processEntry)
            } else {
                entries.push(... batch)
                readBatch() // Must call multiple times! 
            }
        })
    }
    readBatch()
}
```

### Wrapper Value
**High**—converting callbacks to Promises and handling the multi-batch `readEntries` pattern is essential.

---

## 3. File System Access API (User File System)

### What It Is
The modern API for full read/write access to the user's local file system, with native picker dialogs.  Currently a WICG draft, well-supported only in Chromium browsers.

### Key Interfaces
```typescript
interface FileSystemHandle {
    readonly kind: 'file' | 'directory'
    readonly name: string
    isSameEntry(other: FileSystemHandle): Promise<boolean>
    queryPermission(descriptor?:  FileSystemHandlePermissionDescriptor): Promise<PermissionState>
    requestPermission(descriptor?:  FileSystemHandlePermissionDescriptor): Promise<PermissionState>
}

interface FileSystemFileHandle extends FileSystemHandle {
    readonly kind: 'file'
    getFile(): Promise<File>
    createWritable(options?:  FileSystemCreateWritableOptions): Promise<FileSystemWritableFileStream>
}

interface FileSystemDirectoryHandle extends FileSystemHandle {
    readonly kind: 'directory'
    getFileHandle(name: string, options?: { create?:  boolean }): Promise<FileSystemFileHandle>
    getDirectoryHandle(name: string, options?:  { create?: boolean }): Promise<FileSystemDirectoryHandle>
    removeEntry(name:  string, options?: { recursive?:  boolean }): Promise<void>
    resolve(possibleDescendant: FileSystemHandle): Promise<string[] | null>
    values(): AsyncIterableIterator<FileSystemHandle>
    keys(): AsyncIterableIterator<string>
    entries(): AsyncIterableIterator<[string, FileSystemHandle]>
}

interface FileSystemWritableFileStream extends WritableStream {
    write(data: FileSystemWriteChunkType): Promise<void>
    seek(position: number): Promise<void>
    truncate(size:  number): Promise<void>
}
```

### Picker Functions (Global)
```typescript
declare function showOpenFilePicker(options?: OpenFilePickerOptions): Promise<FileSystemFileHandle[]>
declare function showSaveFilePicker(options?: SaveFilePickerOptions): Promise<FileSystemFileHandle>
declare function showDirectoryPicker(options?: DirectoryPickerOptions): Promise<FileSystemDirectoryHandle>
```

### Browser Support Matrix
| Feature | Chrome | Edge | Safari | Firefox |
|---------|--------|------|--------|---------|
| `showOpenFilePicker` | ✅ 86+ | ✅ 86+ | ❌ | ❌ |
| `showSaveFilePicker` | ✅ 86+ | ✅ 86+ | ❌ | ❌ |
| `showDirectoryPicker` | ✅ 86+ | ✅ 86+ | ❌ | ❌ |
| `FileSystemFileHandle` | ✅ | ✅ | ⚠️ Partial | ⚠️ Partial |
| `createWritable` | ✅ | ✅ | ❌ | ❌ |

### Wrapper Value
**High**—needs feature detection, fallbacks for non-Chromium browsers, and unified error handling.

---

## 4. Origin Private File System (OPFS)

### What It Is
A sandboxed, origin-private file system built into the browser.  Files are stored persistently but are invisible to users (not in Downloads, Documents, etc.). Part of the WHATWG File System Standard.

### Access Modes

| Mode | Context | Performance | Use Case |
|------|---------|-------------|----------|
| Async | Main thread / Worker | Good | General file I/O |
| Sync | Worker only | Excellent | Databases, high-throughput |

### Key Interfaces
```typescript
// Entry point
interface StorageManager {
    getDirectory(): Promise<FileSystemDirectoryHandle>
    estimate(): Promise<StorageEstimate>
}

// Sync access (Workers only)
interface FileSystemSyncAccessHandle {
    read(buffer: ArrayBufferView, options?: FileSystemReadWriteOptions): number
    write(buffer: ArrayBufferView, options?: FileSystemReadWriteOptions): number
    truncate(newSize: number): void
    getSize(): number
    flush(): void
    close(): void
}
```

### Browser Support
| Feature | Chrome | Edge | Safari | Firefox |
|---------|--------|------|--------|---------|
| `navigator.storage.getDirectory()` | ✅ 86+ | ✅ 86+ | ✅ 15. 2+ | ✅ 111+ |
| `FileSystemSyncAccessHandle` | ✅ 102+ | ✅ 102+ | ✅ 15.2+ | ✅ 111+ |

### Wrapper Value
**Critical**—OPFS has universal modern browser support and should be the foundation of any persistent file storage wrapper.

---

## Wrapper Architecture Proposal

### Design Philosophy

Following the same patterns as `@mikesaintsg/indexeddb`:
1. **Enhance, don't abstract**:  Expose native handles via `.native`
2. **Promise-based**: Convert all callbacks to async/await
3. **Type-safe**: Generic schemas and strict typing
4. **Zero dependencies**: Use only native platform APIs
5. **Layered access**:  OPFS for storage, File System Access for user interaction

### Proposed Interface Hierarchy

```typescript
// ============================================================
// Core Types
// ============================================================

/** Valid file system entry kinds */
type EntryKind = 'file' | 'directory'

/** File metadata snapshot */
interface FileMetadata {
    readonly name: string
    readonly size: number
    readonly type: string
    readonly lastModified: number
}

/** Directory entry for iteration */
interface DirectoryEntry {
    readonly name: string
    readonly kind: EntryKind
    readonly handle: FileSystemHandle
}

/** Write operation types */
type WriteData = 
    | string 
    | BufferSource 
    | Blob 
    | ReadableStream<Uint8Array>

/** Seek/write options */
interface WriteOptions {
    readonly position?: number
    readonly keepExistingData?: boolean
}

// ============================================================
// Error Types
// ============================================================

type FileSystemErrorCode =
    | 'NOT_FOUND'
    | 'NOT_ALLOWED'
    | 'TYPE_MISMATCH'
    | 'NO_MODIFICATION_ALLOWED'
    | 'INVALID_STATE'
    | 'QUOTA_EXCEEDED'
    | 'ABORT'
    | 'SECURITY'
    | 'ENCODING'
    | 'NOT_SUPPORTED'

interface FileSystemError extends Error {
    readonly code: FileSystemErrorCode
    readonly path?: string
    readonly cause?: Error
}

// ============================================================
// File Interface
// ============================================================

interface FileInterface {
    /** Native file handle */
    readonly native: FileSystemFileHandle

    // Accessors
    getName(): string
    getMetadata(): Promise<FileMetadata>
    
    // Reading
    getText(): Promise<string>
    getArrayBuffer(): Promise<ArrayBuffer>
    getBlob(): Promise<Blob>
    getStream(): ReadableStream<Uint8Array>
    
    // Writing (atomic by default)
    write(data: WriteData, options?: WriteOptions): Promise<void>
    append(data: WriteData): Promise<void>
    truncate(size: number): Promise<void>
    
    // Streaming write (for large files)
    openWritable(): Promise<WritableFileInterface>
    
    // Permissions
    hasReadPermission(): Promise<boolean>
    hasWritePermission(): Promise<boolean>
    requestWritePermission(): Promise<boolean>
    
    // Comparison
    isSameEntry(other: FileInterface): Promise<boolean>
}

// ============================================================
// Writable File Interface (Streaming)
// ============================================================

interface WritableFileInterface {
    /** Native writable stream */
    readonly native: FileSystemWritableFileStream

    write(data: WriteData): Promise<void>
    seek(position: number): Promise<void>
    truncate(size: number): Promise<void>
    close(): Promise<void>
    abort(): Promise<void>
}

// ============================================================
// Directory Interface
// ============================================================

interface DirectoryInterface {
    /** Native directory handle */
    readonly native: FileSystemDirectoryHandle

    // Accessors
    getName(): string
    
    // File operations
    getFile(name: string): Promise<FileInterface | undefined>
    resolveFile(name: string): Promise<FileInterface>
    createFile(name: string): Promise<FileInterface>
    hasFile(name: string): Promise<boolean>
    removeFile(name: string): Promise<void>
    
    // Directory operations
    getDirectory(name: string): Promise<DirectoryInterface | undefined>
    resolveDirectory(name: string): Promise<DirectoryInterface>
    createDirectory(name: string): Promise<DirectoryInterface>
    hasDirectory(name: string): Promise<boolean>
    removeDirectory(name:  string, options?: { recursive?: boolean }): Promise<void>
    
    // Path operations (like Node.js)
    resolvePath(... segments: readonly string[]): Promise<FileInterface | DirectoryInterface | undefined>
    createPath(...segments: readonly string[]): Promise<DirectoryInterface>
    
    // Iteration
    entries(): AsyncIterable<DirectoryEntry>
    files(): AsyncIterable<FileInterface>
    directories(): AsyncIterable<DirectoryInterface>
    
    // Bulk operations
    list(): Promise<readonly DirectoryEntry[]>
    listFiles(): Promise<readonly FileInterface[]>
    listDirectories(): Promise<readonly DirectoryInterface[]>
    
    // Recursive operations
    walk(options?: WalkOptions): AsyncIterable<WalkEntry>
    
    // Permissions
    hasReadPermission(): Promise<boolean>
    hasWritePermission(): Promise<boolean>
    requestWritePermission(): Promise<boolean>
    
    // Comparison
    isSameEntry(other: DirectoryInterface): Promise<boolean>
    resolve(descendant: FileInterface | DirectoryInterface): Promise<readonly string[] | null>
}

interface WalkOptions {
    readonly maxDepth?: number
    readonly includeFiles?: boolean
    readonly includeDirectories?:  boolean
    readonly filter?: (entry: DirectoryEntry, depth: number) => boolean
}

interface WalkEntry {
    readonly path: readonly string[]
    readonly entry: DirectoryEntry
    readonly depth:  number
}

// ============================================================
// File System Interface (Root)
// ============================================================

interface FileSystemInterface {
    // OPFS access (always available)
    getRoot(): Promise<DirectoryInterface>
    
    // Storage info
    getQuota(): Promise<StorageQuota>
    
    // User file system access (Chromium only, feature-detected)
    isUserAccessSupported(): boolean
    
    // Picker dialogs
    showOpenFilePicker(options?: OpenFilePickerOptions): Promise<readonly FileInterface[]>
    showSaveFilePicker(options?: SaveFilePickerOptions): Promise<FileInterface>
    showDirectoryPicker(options?:  DirectoryPickerOptions): Promise<DirectoryInterface>
    
    // Drag-drop support (from DataTransferItem)
    fromDataTransferItem(item: DataTransferItem): Promise<FileInterface | DirectoryInterface | null>
    fromDataTransferItems(items: DataTransferItemList): Promise<readonly (FileInterface | DirectoryInterface)[]>
    
    // From File API (input element)
    fromFile(file: File): Promise<FileInterface>
    fromFiles(files: FileList): Promise<readonly FileInterface[]>
}

interface StorageQuota {
    readonly usage:  number
    readonly quota: number
    readonly available: number
    readonly percentUsed: number
}

// ============================================================
// Picker Options
// ============================================================

interface FilePickerAcceptType {
    readonly description?:  string
    readonly accept:  Readonly<Record<string, readonly string[]>>
}

interface OpenFilePickerOptions {
    readonly multiple?:  boolean
    readonly excludeAcceptAllOption?: boolean
    readonly types?: readonly FilePickerAcceptType[]
    readonly id?: string
    readonly startIn?: StartInDirectory
}

interface SaveFilePickerOptions {
    readonly suggestedName?: string
    readonly excludeAcceptAllOption?: boolean
    readonly types?: readonly FilePickerAcceptType[]
    readonly id?:  string
    readonly startIn?: StartInDirectory
}

interface DirectoryPickerOptions {
    readonly id?: string
    readonly startIn?: StartInDirectory
    readonly mode?: 'read' | 'readwrite'
}

type StartInDirectory = 
    | 'desktop' 
    | 'documents' 
    | 'downloads' 
    | 'music' 
    | 'pictures' 
    | 'videos'
    | FileSystemHandle
```

### Factory Functions

```typescript
/**
 * Creates a file system interface for the origin private file system. 
 * 
 * @returns Promise resolving to FileSystemInterface
 * @example
 * ```ts
 * const fs = await createFileSystem()
 * const root = await fs. getRoot()
 * const file = await root. createFile('hello.txt')
 * await file.write('Hello, OPFS!')
 * ```
 */
export function createFileSystem(): Promise<FileSystemInterface>

/**
 * Creates a directory interface from a native handle.
 * 
 * @param handle - Native FileSystemDirectoryHandle
 * @returns DirectoryInterface
 */
export function fromDirectoryHandle(handle:  FileSystemDirectoryHandle): DirectoryInterface

/**
 * Creates a file interface from a native handle.
 * 
 * @param handle - Native FileSystemFileHandle
 * @returns FileInterface
 */
export function fromFileHandle(handle: FileSystemFileHandle): FileInterface
```

---

## Implementation Strategy

### Phase 1: Core OPFS Wrapper
OPFS has universal browser support and should be the foundation: 

1. `FileInterface` implementation wrapping `FileSystemFileHandle`
2. `DirectoryInterface` implementation wrapping `FileSystemDirectoryHandle`
3. `FileSystemInterface` with `getRoot()` via `navigator.storage.getDirectory()`
4. Error mapping from native `DOMException` to typed errors

### Phase 2: File System Access API Integration
Feature-detected layer for user file system access: 

1. Implement picker methods with capability detection
2. Graceful degradation for non-Chromium browsers
3. Permission management helpers

### Phase 3: Legacy API Support
For drag-drop and input element compatibility:

1. `fromDataTransferItem()` for drag-drop directories
2. `fromFile()` for `<input type="file">` files
3. Unified interface regardless of source

### Phase 4: Advanced Features
1. `walk()` recursive directory traversal
2. `createPath()` for mkdir -p semantics
3. Sync access handle support for Workers

---

## Key Design Decisions

### 1.  OPFS as Primary, File System Access as Secondary

```
┌─────────────────────────────────────────────────────────────┐
│                    FileSystemInterface                       │
├─────────────────────────────────────────────────────────────┤
│  getRoot()              → OPFS (universal support)          │
│  showOpenFilePicker()   → File System Access (Chromium)     │
│  fromDataTransferItem() → Entries API fallback              │
└─────────────────────────────────────────────────────────────┘
```

### 2. Atomic Writes by Default

The native `createWritable()` API writes to a temp file and swaps on close. Our wrapper should maintain this atomic behavior: 

```typescript
// Atomic (default) - safe if browser crashes mid-write
await file.write('new content')

// Streaming (explicit) - caller controls commit
const writable = await file. openWritable()
await writable.write(chunk1)
await writable.write(chunk2)
await writable.close() // Commit happens here
```

### 3. Path-Based Operations

Provide familiar Node.js-like path operations:

```typescript
const fs = await createFileSystem()
const root = await fs. getRoot()

// mkdir -p equivalent
const nested = await root.createPath('data', 'cache', 'images')

// Resolve path to file or directory
const config = await root.resolvePath('config', 'settings. json')
```

### 4. Unified Iteration

Consistent async iteration regardless of source:

```typescript
// Iterate directory contents
for await (const entry of directory.entries()) {
    if (entry.kind === 'file') {
        console. log(`File: ${entry.name}`)
    } else {
        console.log(`Directory: ${entry.name}`)
    }
}

// Recursive walk
for await (const { path, entry } of directory.walk()) {
    console.log(`${path. join('/')}/${entry.name}`)
}
```

---

## Browser Compatibility Strategy

### Feature Detection Pattern

```typescript
function isFileSystemAccessSupported(): boolean {
    return typeof globalThis.showOpenFilePicker === 'function'
}

function isOPFSSupported(): boolean {
    return typeof navigator?. storage?.getDirectory === 'function'
}

function isSyncAccessSupported(): boolean {
    return typeof FileSystemSyncAccessHandle !== 'undefined'
}
```

### Graceful Degradation

| Feature | Chromium | Safari | Firefox | Fallback |
|---------|----------|--------|---------|----------|
| OPFS | ✅ | ✅ | ✅ | None needed |
| File pickers | ✅ | ❌ | ❌ | `<input type="file">` |
| Save picker | ✅ | ❌ | ❌ | Download blob |
| Directory picker | ✅ | ❌ | ❌ | Drag-drop only |
| Sync access | ✅ | ✅ | ✅ | Async only |

---

## Comparison with Node.js fs Module

| Node.js `fs` | Browser Wrapper | Notes |
|--------------|-----------------|-------|
| `fs.readFile()` | `file.getText()` / `file.getArrayBuffer()` | Async only |
| `fs.writeFile()` | `file.write()` | Atomic by default |
| `fs.appendFile()` | `file.append()` | |
| `fs.readdir()` | `directory.list()` | Returns entry objects |
| `fs.mkdir()` | `directory.createDirectory()` | |
| `fs.mkdir(p, { recursive: true })` | `directory.createPath()` | |
| `fs.rm()` | `directory.removeFile/Directory()` | |
| `fs.stat()` | `file.getMetadata()` | |
| `fs.existsSync()` | `directory.hasFile/Directory()` | Always async |
| `fs.createReadStream()` | `file.getStream()` | |
| `fs.createWriteStream()` | `file.openWritable()` | |

---

## Summary

### Recommended Approach

1. **Build on OPFS** as the universal foundation—it has the best browser support
2. **Layer File System Access API** for user file interaction with feature detection
3. **Provide fallbacks** via File API and Entries API for non-Chromium browsers
4. **Follow your IndexedDB wrapper patterns**:  Promise-based, typed, `.native` escape hatch

### Estimated Scope

| Component | Interfaces | Complexity |
|-----------|------------|------------|
| Core types | ~15 | Low |
| File operations | 3 | Medium |
| Directory operations | 3 | Medium |
| File system root | 1 | Low |
| Picker integration | 1 | Medium |
| Legacy API adapters | 2 | Low |
| Error handling | 1 | Low |
| **Total** | **~25** | **Medium** |

This is a smaller API surface than your IndexedDB wrapper but with similar architectural patterns. The main complexity is handling the three distinct API sources (OPFS, File System Access, Entries API) through a unified interface.